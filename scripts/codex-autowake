#!/usr/bin/env bash
set -euo pipefail
#
# Codex autowake — loop through GitHub issues labeled 'codex'.
#
# Fetches the next open issue, runs Codex in full-auto mode, then
# waits for a cooldown before the next cycle. Tickle monitors agent
# activity on the server and pages if Codex stalls mid-task.
#
# Usage:
#   ./scripts/codex-autowake                        # default settings
#   AUTOWAKE_MAX_CYCLES=10 ./scripts/codex-autowake # more cycles
#   AUTOWAKE_COOLDOWN=30 ./scripts/codex-autowake   # shorter cooldown
#
# Environment:
#   AUTOWAKE_MAX_CYCLES   — max issue cycles (default: 5)
#   AUTOWAKE_COOLDOWN     — seconds between cycles (default: 60)
#   AUTOWAKE_LABEL        — GitHub issue label to pick (default: codex)
#   AUTOWAKE_MISSION      — mission-id for evidence traceability
#   CODEX_CMD             — codex command + flags (default: auto-detected)
#   FUTON3C_EVIDENCE_BASE — Agency URL (default: http://localhost:7070)

MAX_CYCLES="${AUTOWAKE_MAX_CYCLES:-5}"
COOLDOWN="${AUTOWAKE_COOLDOWN:-60}"
LABEL="${AUTOWAKE_LABEL:-codex}"
MISSION="${AUTOWAKE_MISSION:-M-unscoped}"
PATTERN="R11"
evidence_base="${FUTON3C_EVIDENCE_BASE:-http://localhost:7070}"

# Codex command: non-interactive, no approval prompts, full sandbox access
if [[ -n "${CODEX_CMD:-}" ]]; then
  CODEX=($CODEX_CMD)
else
  CODEX=(codex exec -c approval_policy=\"never\" --sandbox danger-full-access)
fi

# Determine repo from git remote
REPO="$(git remote get-url origin 2>/dev/null | sed -E 's|.*github\.com[:/]||;s|\.git$||')"
if [[ -z "$REPO" ]]; then
  echo "[autowake] Could not determine GitHub repo from git remote." >&2
  exit 1
fi

echo "[autowake] Starting autowake loop"
echo "[autowake]   repo:       ${REPO}"
echo "[autowake]   mission:    ${MISSION}"
echo "[autowake]   pattern:    ${PATTERN}"
echo "[autowake]   label:      ${LABEL}"
echo "[autowake]   max_cycles: ${MAX_CYCLES}"
echo "[autowake]   cooldown:   ${COOLDOWN}s"
echo "[autowake]   agency:     ${evidence_base}"
echo "[autowake]   codex_cmd:  ${CODEX[*]}"
echo

json_escape() {
  sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' <<< "${1:-}"
}

# ── Read-side: fetch evidence to guide Codex ──────────────────────────

fetch_psr() {
  # Fetch the Pattern Selection Record for a given issue number.
  # Returns a human-readable summary or empty string.
  local issue_num="$1"
  command -v curl >/dev/null 2>&1 || return 0
  local raw
  raw="$(curl -sS --max-time 3 \
    "${evidence_base%/}/api/alpha/evidence?tag=psr&tag=${MISSION}" \
    2>/dev/null)" || return 0
  python3 -c "
import sys, json
try:
    data = json.loads(sys.argv[1])
    entries = data.get('entries', data) if isinstance(data, dict) else data
    issue = int(sys.argv[2])
    for e in entries:
        b = e.get('evidence/body', e.get('body', {}))
        if isinstance(b, str): b = json.loads(b)
        # PSR entries use psr/issue key
        entry_issue = b.get('psr/issue', b.get('issue'))
        if entry_issue == issue:
            parts = []
            if b.get('psr/pattern'): parts.append(f'pattern: {b[\"psr/pattern\"]}')
            if b.get('psr/pattern-name'): parts.append(f'pattern-name: {b[\"psr/pattern-name\"]}')
            if b.get('psr/context'): parts.append(f'context: {b[\"psr/context\"]}')
            if b.get('psr/rationale'): parts.append(f'rationale: {b[\"psr/rationale\"]}')
            if b.get('psr/decision'): parts.append(f'decision: {b[\"psr/decision\"]}')
            # Also check non-prefixed keys (early PSR format)
            for k in ['pattern-id','context','rationale']:
                if b.get(k) and not any(k in p for p in parts):
                    parts.append(f'{k}: {b[k]}')
            if parts: print('\\n'.join(parts))
            break
except: pass
" "$raw" "$issue_num" 2>/dev/null || true
}

fetch_recent_purs() {
  # Fetch recent Pattern Use Records for the current mission.
  # Returns a human-readable summary of outcomes for learning context.
  command -v curl >/dev/null 2>&1 || return 0
  local raw
  raw="$(curl -sS --max-time 3 \
    "${evidence_base%/}/api/alpha/evidence?tag=pur&tag=${MISSION}" \
    2>/dev/null)" || return 0
  python3 -c "
import sys, json
try:
    data = json.loads(sys.argv[1])
    entries = data.get('entries', data) if isinstance(data, dict) else data
    lines = []
    for e in entries:
        b = e.get('evidence/body', e.get('body', {}))
        if isinstance(b, str): b = json.loads(b)
        # Only include actual PUR entries (have pur/issue key)
        if 'pur/issue' not in b: continue
        issue = b['pur/issue']
        outcome = b.get('pur/outcome', '?')
        title = b.get('pur/title', '')[:60]
        files = b.get('pur/file-list', '')
        lines.append(f'  #{issue} ({outcome}): {title}')
        if files: lines.append(f'    files: {files}')
        if len(lines) >= 10: break  # ~5 entries with file info
    if lines: print('\\n'.join(lines))
except: pass
" "$raw" 2>/dev/null || true
}

fetch_mission_context() {
  # Fetch current mission checkpoint/health status.
  command -v curl >/dev/null 2>&1 || return 0
  local health
  health="$(curl -sS --max-time 2 "${evidence_base%/}/health" 2>/dev/null)" || return 0
  python3 -c "
import sys, json
try:
    h = json.loads(sys.argv[1])
    parts = []
    if 'agents' in h: parts.append(f'agents: {h[\"agents\"]}')
    if 'evidence' in h: parts.append(f'evidence entries: {h[\"evidence\"]}')
    if 'uptime-seconds' in h: parts.append(f'uptime: {h[\"uptime-seconds\"]}s')
    if parts: print(', '.join(parts))
except: pass
" "$health" 2>/dev/null || true
}

register_agent() {
  command -v curl >/dev/null 2>&1 || return 0
  curl -sS --max-time 2 \
    -H "Content-Type: application/json" \
    -X POST \
    -d '{"agent-id":"codex-1","type":"codex"}' \
    "${evidence_base%/}/api/alpha/agents" >/dev/null 2>&1 || true
}

emit_evidence() {
  # Emit a futonic evidence entry with pattern + mission traceability.
  # Usage: emit_evidence <event> [issue_num] [title] [extra_body_json]
  local event="$1" issue_num="${2:-0}" title="${3:-}" extra="${4:-}"
  command -v curl >/dev/null 2>&1 || return 0
  local escaped_title commit_sha
  escaped_title="$(json_escape "$title")"
  commit_sha="$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")"
  local body="{\"event\":\"${event}\",\"issue\":${issue_num},\"title\":\"${escaped_title}\",\"pattern-id\":\"${PATTERN}\",\"mission-id\":\"${MISSION}\",\"commit-sha\":\"${commit_sha}\"${extra:+,${extra}}}"
  curl -sS --max-time 2 \
    -H "Content-Type: application/json" \
    -X POST \
    -d "{\"subject\":{\"ref/type\":\"mission\",\"ref/id\":\"${MISSION}\"},\"type\":\"coordination\",\"claim-type\":\"observation\",\"author\":\"codex-1\",\"pattern-id\":\"${PATTERN}\",\"session-id\":\"autowake/${MISSION}\",\"body\":${body},\"tags\":[\"codex\",\"autowake\",\"${event}\",\"${PATTERN}\",\"${MISSION}\"]}" \
    "${evidence_base%/}/api/alpha/evidence" >/dev/null 2>&1 || true
}

emit_pur() {
  # Layer 2: Pattern Use Record — emitted after each Codex cycle.
  # Records outcome, files changed, commit range, and any prediction errors.
  local issue_num="$1" title="$2" outcome="$3" pre_sha="$4" post_sha="$5"
  command -v curl >/dev/null 2>&1 || return 0
  local escaped_title files_changed file_list
  escaped_title="$(json_escape "$title")"
  if [[ "$pre_sha" != "$post_sha" && "$pre_sha" != "unknown" ]]; then
    files_changed="$(git diff --stat "${pre_sha}..${post_sha}" 2>/dev/null | tail -1 | sed 's/^ *//' | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')"
    file_list="$(git diff --name-only "${pre_sha}..${post_sha}" 2>/dev/null | head -20 | paste -sd',' | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')"
  else
    files_changed="no changes detected"
    file_list=""
  fi
  curl -sS --max-time 3 \
    -H "Content-Type: application/json" \
    -X POST \
    -d "{
      \"subject\":{\"ref/type\":\"mission\",\"ref/id\":\"${MISSION}\"},
      \"type\":\"reflection\",
      \"claim-type\":\"observation\",
      \"author\":\"codex-1\",
      \"pattern-id\":\"${PATTERN}\",
      \"session-id\":\"pur/${MISSION}\",
      \"body\":{
        \"pur/pattern\":\"${PATTERN}\",
        \"pur/pattern-name\":\"scope-bounded-handoff\",
        \"pur/issue\":${issue_num},
        \"pur/mission\":\"${MISSION}\",
        \"pur/outcome\":\"${outcome}\",
        \"pur/pre-sha\":\"${pre_sha}\",
        \"pur/post-sha\":\"${post_sha}\",
        \"pur/files-changed\":\"${files_changed}\",
        \"pur/file-list\":\"${file_list}\",
        \"pur/title\":\"${escaped_title}\"
      },
      \"tags\":[\"pur\",\"${PATTERN}\",\"${MISSION}\",\"mission-control\"]
    }" \
    "${evidence_base%/}/api/alpha/evidence" >/dev/null 2>&1 || true
}

emit_checkpoint() {
  # Layer 4: Gate checkpoint — snapshot of progress after each cycle.
  # Captures test count, evidence count, agent count, commit position.
  local cycle_num="$1" issue_num="$2" outcome="$3"
  command -v curl >/dev/null 2>&1 || return 0
  local commit_sha evidence_count agent_count
  commit_sha="$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")"
  # Query health for counts (evidence count available if #22 is deployed)
  local health_json
  health_json="$(curl -sS --max-time 2 "${evidence_base%/}/health" 2>/dev/null || echo "{}")"
  evidence_count="$(echo "$health_json" | python3 -c 'import sys,json; print(json.load(sys.stdin).get("evidence",0))' 2>/dev/null || echo 0)"
  agent_count="$(echo "$health_json" | python3 -c 'import sys,json; print(json.load(sys.stdin).get("agents",0))' 2>/dev/null || echo 0)"
  curl -sS --max-time 3 \
    -H "Content-Type: application/json" \
    -X POST \
    -d "{
      \"subject\":{\"ref/type\":\"mission\",\"ref/id\":\"${MISSION}\"},
      \"type\":\"coordination\",
      \"claim-type\":\"observation\",
      \"author\":\"codex-1\",
      \"pattern-id\":\"${PATTERN}\",
      \"session-id\":\"checkpoint/${MISSION}\",
      \"body\":{
        \"checkpoint/cycle\":${cycle_num},
        \"checkpoint/issue\":${issue_num},
        \"checkpoint/outcome\":\"${outcome}\",
        \"checkpoint/commit-sha\":\"${commit_sha}\",
        \"checkpoint/evidence-count\":${evidence_count},
        \"checkpoint/agent-count\":${agent_count},
        \"checkpoint/mission\":\"${MISSION}\"
      },
      \"tags\":[\"checkpoint\",\"${PATTERN}\",\"${MISSION}\",\"mission-control\"]
    }" \
    "${evidence_base%/}/api/alpha/evidence" >/dev/null 2>&1 || true
}

register_agent
emit_evidence "autowake-start" 0 "starting ${MAX_CYCLES} cycles"

cycle=0
while [[ $cycle -lt $MAX_CYCLES ]]; do
  cycle=$((cycle + 1))
  ts="$(date -u +%H:%M:%SZ)"
  echo "[autowake] ===== Cycle ${cycle}/${MAX_CYCLES} ${ts} ====="

  # Pull latest before each cycle so we build on Codex's own commits
  git pull --rebase origin master 2>/dev/null || true

  # Fetch next open issue labeled for codex
  issue_json="$(gh issue list --repo "$REPO" --label "$LABEL" --state open --limit 1 --json number,title,body -q '.[0]' 2>/dev/null || echo "")"

  if [[ -z "$issue_json" || "$issue_json" == "null" ]]; then
    echo "[autowake] No open issues with label '${LABEL}'. Sleeping ${COOLDOWN}s..."
    sleep "$COOLDOWN"
    continue
  fi

  number="$(echo "$issue_json" | jq -r '.number')"
  title="$(echo "$issue_json" | jq -r '.title')"
  body="$(echo "$issue_json" | jq -r '.body')"

  echo "[autowake] Issue #${number}: ${title}"
  emit_evidence "issue-start" "$number" "$title"

  # ── Read-side: gather evidence context for this issue ──
  psr_context="$(fetch_psr "$number")"
  pur_context="$(fetch_recent_purs)"
  mission_health="$(fetch_mission_context)"

  evidence_section=""
  if [[ -n "$psr_context" || -n "$pur_context" || -n "$mission_health" ]]; then
    evidence_section="
--- Evidence Context (from the mission evidence landscape) ---"
    if [[ -n "$psr_context" ]]; then
      evidence_section="${evidence_section}

Pattern Selection (why this issue exists):
${psr_context}"
    fi
    if [[ -n "$pur_context" ]]; then
      evidence_section="${evidence_section}

Recent outcomes from this mission (learn from these):
${pur_context}"
    fi
    if [[ -n "$mission_health" ]]; then
      evidence_section="${evidence_section}

Current system state: ${mission_health}"
    fi
    evidence_section="${evidence_section}
---"
    echo "[autowake] Injected evidence context into prompt"
  fi

  # Build prompt from issue + evidence context
  prompt="You are working on GitHub issue #${number} in the ${REPO} repository.
Mission: ${MISSION} | Pattern: ${PATTERN}

Title: ${title}

${body}
${evidence_section}

Instructions:
1. Read the :in files listed in the issue for context
2. Create/modify the :out files as specified
3. Run \`clojure -X:test\` to verify all tests pass
4. Commit your changes referencing issue #${number}
5. Push to origin/master when all criteria in the checklist are met"

  # Capture pre-codex SHA for diff
  pre_sha="$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")"

  # Run codex
  echo "[autowake] Running ${CODEX[*]} ..."
  if "${CODEX[@]}" "$prompt" 2>&1; then
    post_sha="$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")"
    echo "[autowake] Codex completed issue #${number}. (${pre_sha}..${post_sha})"
    emit_evidence "issue-done" "$number" "$title" \
      "\"pre-sha\":\"${pre_sha}\",\"post-sha\":\"${post_sha}\""
    emit_pur "$number" "$title" "success" "$pre_sha" "$post_sha"
    emit_checkpoint "$cycle" "$number" "success"
    gh issue close "$number" --repo "$REPO" \
      --comment "Completed by Codex autowake (${MISSION}, pattern ${PATTERN}). Commits: ${pre_sha}..${post_sha}" \
      2>/dev/null || true
  else
    post_sha="$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")"
    echo "[autowake] Codex exited with error on issue #${number}."
    emit_evidence "issue-error" "$number" "$title" \
      "\"pre-sha\":\"${pre_sha}\",\"post-sha\":\"${post_sha}\""
    emit_pur "$number" "$title" "failure" "$pre_sha" "$post_sha"
    emit_checkpoint "$cycle" "$number" "failure"
    # Remove label so we don't retry the same issue; add codex-failed
    gh issue edit "$number" --repo "$REPO" \
      --remove-label "$LABEL" --add-label "codex-failed" 2>/dev/null || true
    gh issue comment "$number" --repo "$REPO" \
      --body "Codex autowake (${MISSION}): exited with error. Removing from queue." \
      2>/dev/null || true
  fi

  register_agent

  if [[ $cycle -lt $MAX_CYCLES ]]; then
    echo "[autowake] Cooldown ${COOLDOWN}s..."
    sleep "$COOLDOWN"
  fi
done

emit_evidence "autowake-done" 0 "completed ${MAX_CYCLES} cycles"
echo "[autowake] All ${MAX_CYCLES} cycles complete."
